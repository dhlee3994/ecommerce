# 트랜잭션 분리

## 개요

서비스의 규모가 확장되어 MSA의 형태로 각 도메인별로 배포단위를 분리해야하는 상황을 가정하고, 트랜잭션을 분리한다.  
트랜잭션을 분리할 API 시나리오는 "결제 API"이다.  
"결제 API"는 `user`, `point`, `order`, `issuedCoupon`, `payment` 도메인이 협력하는 API기 때문에  
트랜잭션 분리를 연습하기에 좋은 시나리오라고 생각했다.

## 도메인 구성

- 유저: 유저 정보 조회
- 포인트: 유저 포인트 조회, 포인트 차감
- 상품: 상품 조회, 상품 재고 차감
- 쿠폰: 쿠폰 조회, 쿠폰 발급, 쿠폰 사용
- 주문: 주문 생성, 주문 조회, 주문 상태 변경
- 결제: 결제 이력 생성

## 결제 API 분리

### 결제 API 트랜잭션 범위

"결제 API"의 트랜잭션(이하 tx) 범위는 아래와 같다.  

```markdown
결제_tx(user_id, order_id, coupon_id) {
  유저_유효성_검사(user_id);
  주문_조회_및_유효성_검사(order_id);
  쿠폰_조회(coupon_id);
  포인트_조회(user_id);
  결제_금액_계산(order_id, coupon_id); // 주문 금액, 할인 타입, 할인 값
  결제_객체_생성();
  쿠폰_사용_처리(coupon_id);
  포인트_차감(user_id);
  주문_상태_변경(order_id);
  외부_플랫폼으로_주문_데이터_전송();
}
```

### 결제 API 분리

결제 도메인에서 한번에 호출하던 서비스들을 각각의 도메인으로 나누어 트랜잭션을 분리하였다.   
이때, 결제 금액을 계산하기 위해서는 주문 금액, 쿠폰할인 타입, 쿠폰할인 값 정보가 필요하다.  
결제 도메인에서 주문, 쿠폰 도메인에 API(또는 이벤트)를 호출해서 결과를 받는 방법과 애초에 파라미터로 전달받는 방법이 있을 것이다.  
전자는 다른 서비스 상태에 영향을 받기 때문에 후자의 방법을 선택했다.

```markdown
결제_tx(user_id, order_id, coupon_id, 주문_금액, 할인_타입, 할인_값) {
  결제_금액_계산(주문_금액, 할인_타입, 할인_값);
  결제_객체_생성();
}

유저_tx(user_id) {
  유저_유효성_검사(user_id);
}

쿠폰_tx(coupon_id, 할인_타입, 할인_값) {
  쿠폰_조회(coupon_id);
  쿠폰_유효성_검사(할인_타입, 할인_값); // 추가
  쿠폰_사용_처리(coupon_id);
}

포인트_tx(user_id) {
  포인트_조회(user_id);
  포인트_차감(user_id);
}

주문_tx(order_id, 주문_금액) {
  주문_조회_및_유효성_검사(order_id);
  주문_금액_유효성_검사(주문_금액); // 추가
  주문_상태_변경(order_id);
}

외부_플랫폼_전송_tx() {
  외부_플랫폼_전송();
}
```

## 트랜잭션을 분리했을 때의 문제점과 적용가능한 해결책

### 발생가능한 문제점

1. 데이터 무결성 문제: 한 서비스에서 오류가 발생하면 이전 서비스들의 변경사항은 롤백되어야 하는데, 이를 보장하기 어려움
2. ACID 속성을 보장하기 어려움: 각 서비스가 독립적인 DB를 사용하므로 ACID 속성을 보장하기 어려움 
3. 네트워크 오버헤드 및 이벤트 지연: 여러 서비스를 호출하고, 이에 대한 결과를 기다려야해서 성능저하. 동기적 통신이 맞을 경우 네트워크 오버헤드 증가

### 적용가능한 해결책

#### 2PC(Tow-Phase Commit)

##### 개요

모든 참여 서비스가 트랜잭션 완료 여부를 결정하는 2단계 과정을 거쳐 데이터 일관성을 유지한다. 작동 순서는 아래와 같다.  
- 1단계(준비 단계): 코디네이터가 모든 서비스에게 트랜잭션 준비 요청을 보내고, 서비스는 로컬 트랜잭션의 준비 결과를 코디네이터에게 응답
- 2단계(커밋/롤백 단계): 코디네이터는 모든 서비스가 준비 완료되어 있으면 커밋 요청을, 그렇지 않으면 롤백 요청을 보냄

##### 장점

- 강력한 원자성 보장

##### 단점

- 높은 결합도: 서비스 간 강한 경합을 유발해서 MSA의 장점을 퇴색시킴
- 성능 저하: 모든 서비스의 트랜잭션이 완료될 때 까지 대기해야해서 성능 저하
- 장애 취약: 코디네이터에 장애가 발생하면 전체 시스템에 영향을 끼침

##### 종합

- MSA에 부적합

#### SAGA with Choreography

##### 개요

이벤트가 발행되면 서비스들은 해당 이벤트를 구독해 자신의 트랜잭션을 처리  

##### 장점

- 느슨한 결합
- 높은 확장성

##### 단점

- 복잡한 로직: 서비스간 의존, 상태 관리가 복잡함
- 추적 어려움: 트래잭션 진행 상황 추적이 어령무
- 오류 복구 어려움: 각 서비스가 보상 트랜잭션을 처리해야 하는데 추적이 어려우므로 오류 복구가 어려움

##### 종합

- MSA 환경에 적합
- 복잡함
- 오류 처리 어려움

#### SAGA with Orchestration

##### 개요

오케스트레이터 서비스가 각 서비스의 트랜잭션 흐름을 관리

##### 장점

- 중앙 집중식 관리
- 트랜잭션 추적 용이

##### 단점

- 장애 취약: 오케스트레이터 서비스에 장애가 발생하면 전체 시스템에 영향을 끼침
- 복잡한 로직: 오케스트레이터가 모든 서비스의 트랜잭션 흐름을 관리해야하므로 로직이 복잡해짐

##### 종합

- 트랜잭션 관리의 중앙 집중화
- 오케스트레이터 의존성
- 복잡한 로직

#### 메시지 + Outbox

##### 개요

서비스는 메시지 큐에 보내야 할 메시지를 로컬 DB의 아웃박스 테이블에 저장한다.  
메시지 릴레이 서비스는 주기적으로 아웃박스 테이블을 스캔해서 메시지 큐에 메시지를 전송한다.  

##### 장점

- 느슨한 결합: 서비스 간 독립성 보장
- 높은 안전성: 메시지 전송 실패 시 재전송 보장
- 단순한 로직: 각 서비스는 자기 자신의 트랜잭션만 

##### 단점

- 추가 인프라: 메시지 릴레이 서비스, 메시지 큐 등 추가적인 인프라 구축이 필요
- 메시지 중복 처리: 메시지가 중복 수신될 수 있으므로 이에 대한 처리 필요

##### 종합

- MSA 환경에 적합
- 추가적인 인프라가 필요하다는 단점이 있지만 안정성, 확장성, 개발 편의성의 장점이 있음

### 그래서 결제 API에는 어떤 방식이 적절할까?

MSA환경에 적절하지 않은 2PC 방식은 배제한다. 

#### SAGA with Choreography

1. 결제_tx 작업 후 이벤트 발행
2. 유저_tx 작업 후 이벤트 발행
3. 쿠폰_tx 작업 후 이벤트 발행
4. 포인트_tx 작업 후 이벤트 발행
5. 주문_tx 작업 후 이벤트 발행
6. 외부플랫폼_전송_tx 작업
7. 각 작업을 수행할 때, 각 단계가 성공하면 다음 단계로 진행하고 실패하면 보상 트랜잭션 실행

#### SAGA with Orchestration

1. 결제_tx가 오케스트레이터 역할 수행
2. 결제_tx는 아래의 작업을 수행
    - 유저_tx 호출
    - 쿠폰_tx 호출
    - 포인트_tx 호출
    - 주문_tx 호출
    - 외부플랫폼_전송_tx 호출
3. 2번 작업을 수행할 때, 각 단계가 성공하면 다음 단계로 진행하고 실패하면 보상 트랜잭션 실행

#### 메시지 + Outbox

1. 결제_tx가 로컬 DB의 outbox 테이블에 메시지 데이터 저장
2. 메시지 릴레이 서비스가 주기적으로 outbox 테이블 스캔
3. 스캔한 메시지를 메시지 큐에 전송
4. 각 서비스는 메시지 큐에서 메시지 구독 및 처리
