<!-- TOC -->

* [동시성 문제 해결방법 분석](#동시성-문제-해결방법-분석)
    * [동시성 테스트 세팅 가이드](#동시성-테스트-세팅-가이드)
    * [번외(DB 커넥션 풀)](#번외db-커넥션-풀)
* [시나리오별 적절한 락](#시나리오별-적절한-락)
    * [시나리오별 동시성 방법 성능 비교](#시나리오별-동시성-방법-성능-비교)
    * [시나리오별 테스트 상세 결과](#시나리오별-테스트-상세-결과)
        * [포인트 충전](#포인트-충전)
        * [여러 명이 쿠폰 발급](#여러-명이-쿠폰-발급)
        * [한 명이 여러 번 쿠폰 발급](#한-명이-여러-번-쿠폰-발급)
        * [주문 생성](#주문-생성)
        * [결제](#결제)

<!-- TOC -->

# 동시성 문제 해결방법 분석

- 이커머스 시나리오에서 발생할 수 있는 동시성 문제를 해결하기 위해 낙관적 락, 비관적 락을 적용해본다.
- 락 메커니즘별 성능을 비교해보고, 코드를 작성하면서 느낀 복잡도를 작성한다.
- 쓰레드 풀은 기본 20으로 설정한다. (테스트 진행 컴퓨터의 쓰레드 수 = 10)
- 동시 요청 횟수는 5, 50, 500, 5000으로 설정하여 테스트를 진행하며, 각각 5회씩 측정한다.
- 단, 낙관적 락의 경우 요청 횟수를 50까지만 테스트하며, 쓰레드 풀 크기, 재시도 횟수, 재시도 간격 등을 조절하면서 경향성을 확인한다.
    - 쓰레드 풀 크기가 20인 경우 너무 많은 실패를 하기 때문에 10, 20 모두 테스트한다.
    - 재시도 횟수는 5, 10, 15로 테스트하고, 재시도 간격은 100ms 단위로 테스트한다.
    - 최대 재시도 간격은 1000ms로 설정하며, 동시성 문제를 해결하지 못한 경우 성능을 기록하지 않는다.
- 성능 측정은 `System.currentTimeMillis()`를 이용하여 측정한다.

## 동시성 테스트 세팅 가이드

- `쓰레드 풀 크기 < CountDownLatch = 요청 횟수`
- 쓰레드 풀 크기는 작업의 성격(CPU Bound 프로세스, I/O Bound 프로세스)에 따라 다르게 설정한다.
- CPU Bound 프로세스: 데이터 암호화, 대규모 계산, 이미지 처리, 머신 러닝 등
    - 쓰레드 풀 크기 = `CPU 코어 수` or `CPU 코어 수 + 1~2`
- I/O Bound 프로세스: 네트워크 요청 처리, 데이터베이스 조회, 파일 I/O, API 호출
    - 쓰레드 풀 크기 = (`요청 횟수의 50 ~ 75%` or `CPU 코어 수 * 2`)
        - 요청 횟수의 100%로 하지 않는 이유
            - 대기열 활용: 쓰레드 풀의 크기가 크지 않아도 대기열에 쌓인 작업을 처리하면서 처리량을 유지할 수 있음
                - 오버헤드: 컨텍스트 스위치 오버헤드로 성능이 떨어질 가능성이 있음
                - 현실성: 실제 운영환경과 비슷한 조건에서 테스트
        - `CPU 코어 수 * 2`의 장점
            - I/O 작업은 코어 수 이상의 스레드를 생성해도 CPU가 병목되는 일이 드뭄
            - `코어 수 * 2`는 I/O 대기 상태에서도 CPU를 효율적으로 활용할 가능성을 높임
            - 테스트 대상에 따라 변경되지 않아서 모든 테스트에서 일정한 기준이 됨
        - `CPU 코어 수 * 2`의 단점
            - I/O 대기 시간 비율 무시: I/O 대기 시간 비율이 높을수록 더 많은 스레드가 필요하고, 낮을수록 적은 스레드로도 충분함
            - 요청 횟수에 따라 `CPU 코어 수 * 2` 보다 더 많거나 적은 스레드가 필요할 수 있음
        - 아래의 경우 `CPU 코어 수 * 2`가 적절함
            - 작업 특성을 정확하게 모를 때: I/O 대기 시간이 얼마나 되는지 알 수 없을 때, 적당히 안전한 값으로 테스트
            - 테스트가 요청 횟수에 크게 의존하지 않을 때
            - I/O 대기 비율이 중간 수준일 때: `I/O 대기 시간/CPU 처리 시간`이 2 ~ 3 사이일 때
- 혼합형
    - 쓰레드 풀 크기 = `CPU 코어 수 * (1 + (I/O 대기 시간 / CPU 처리 시간))`

## 번외(DB 커넥션 풀)

- 쓰레드 풀 크기는 DB 커넥션 풀 크기에 영향을 받으며, `쓰레드 풀 크기 >= DB 커넥션 풀 크기`로 설정한다.
    - DB 작업을 포함하지 않는 캐싱, 파일 처리 등의 작업이 많으면 쓰레드 풀의 크기를 더 크게 설정할 수 있다.
- 쓰레드 풀과 DB 커넥션 풀 설정은 서로 영향을 주지만 일반적으로 DB 커넥션 풀을 먼저 설정한다.
    - DB는 처리 가능한 최대 연결 수(max connection)를 넘기면 성능이 급격히 저하된다.
    - DB 작업이 병목 지점이 될 수 있기 때문에, 쓰레드가 많아도 효율이 떨어질 수 있다.
- 결정 순서
    - DB 커넥션 풀 크기 설정
        - DB의 최대 처리 가능 커넥션 수와 애플리케이션 부하를 기준으로 결정
        - I/O 대기 시간이 있는 작업이면 작업 처리량 대비 적절한 커넥션 수 설정
            - `최소 커넥션 풀 크기 = (초당 요청 수 * DB 응답 시간(ms)) / 1000`
    - 쓰레드 풀 크기 설정
        - DB 중심 작업 비율이 높음: 쓰레드 풀 크기 = DB 커넥션 풀 크기
        - 여러 작업이 혼합됨: 쓰레드 풀 크기 > DB 커넥션 풀 크기 (DB 커넥션 풀 크기 * 1.5or2)

# 시나리오별 적절한 락

- 낙관적 락과 비관적 락의 가장 중요한 포인트는 '실패 허용 여부'이다.
    - 낙관적 락의 재시도 성공 여부는 시스템 상태(네트워크, DB 등)에 따라 달라지므로 실패하면 치명적인 경우에는 부적절하다.
- 실패해도 괜찮은 경우, 경합 발생 패턴을 확인해야 한다.
    - 낙관적 락은 경합이 많이 발생하는 경우 재시도 횟수가 많아지므로 시스템에 악영향을 끼칠 수 있다.

- 포인트 충전: 비관적 락
    - 사용자의 '돈'과 관련된 것으로 성능보다는 정합성이 중요하다.
- 선착순 쿠폰 발급: 비관적 락
    - 쿠폰은 회사의 '돈'과 관련된 것으로 정합성이 중요하다.
    - 그리고 선착순이라는 특성상 경합이 많이 발생하므로 낙관적 락을 사용하면 시스템 성능에 악영향을 끼칠 수 있다.
- 주문 생성(상품 재고): 비관적 락
    - 재고는 여러 사용자가 동시에 주문하는 등 변동이 심한 경우가 많아 경합이 많이 발생할 수 있다.
- 결제: 비관적 락
    - 사용자의 '돈'과 관련된 것으로 성능보다는 정합성이 중요하다.

## 시나리오별 동시성 방법 성능 비교

![summary.png](/docs/lock/summary.png)

## 시나리오별 테스트 상세 결과

<details>
<summary>접기/펼치기</summary>

각 테스트별 6회 반복하여 첫 번째 측정 값은 버리고 나머지 5회의 측정 시간을 기록한다.(첫 테스트는 테스트 시간이 약 100ms 정도 추가로 소요되기 때문에 제외한다.)

테스트 상세 결과 확인 가이드

- 비관적락
    - `50회: 19, 16, 16, 16, 16`
        - 50번의 API 요청을 하는 동시성 테스트이다.
        - 총 5회 진행하였고, 각각 19ms, 16ms, 16ms, 16ms, 16ms 소요되었다는 뜻이다.
- 낙관적락
    - `50회 / 쓰레드10 / maxAttempts = 5 / backoff = 100ms: 476, 527, 504, 497, 503`
        - 50번의 API 요청을 하는 동시성 테스트이다.
        - 쓰레드 풀 크기는 10으로 설정하였고, 재시도 횟수는 5회, 재시도 간격은 100ms로 설정하였다.
        - 총 5회 측정하였고, 각각 476ms, 527ms, 504ms, 497ms, 503ms 소요되었다는 뜻이다.

#### 포인트 충전

- 포인트 충전은 동일한 사용자가 동시에 여러 번 포인트 충전 요청을 보내는 경우가 발생할 수 있다.
- 테스트 시나리오
    - 한 명의 사용자가 동시에 N번의 포인트 충전 요청을 한다.
    - 예상 충전 금액과 실제 사용자의 포인트 잔액을 비교해서 동시성 문제가 발생했는지 확인한다.

- 비관적락(단위: ms)
    - 5회: 19, 16, 16, 16, 16
    - 50회: 135, 129, 137, 121, 138
    - 500회: 1121, 1037, 1033, 1025, 1035
    - 5000회: 9666, 9303, 9535, 9454, 9719
- 낙관적락(단위: ms)
    - 5회
        - 쓰레드20 / maxAttempts = 5 / backoff = 100ms: 476, 527, 504, 497, 503
        - 쓰레드20 / maxAttempts = 10 / backoff = 100ms: 496, 515, 467, 491, 470
        - 쓰레드20 / maxAttempts = 15 / backoff = 100ms: 487, 479, 497, 487, 484
        -
        - 쓰레드10 / maxAttempts = 5 / backoff = 100ms: 508, 506, 526, 353, 503
        - 쓰레드10 / maxAttempts = 10 / backoff = 100ms: 482, 483, 506, 483, 498
        - 쓰레드10 / maxAttempts = 15 / backoff = 100ms: 379, 486, 496, 473, 510
    - 50회
        - 쓰레드20 / maxAttempts = 5: 실패
        - 쓰레드20 / maxAttempts = 10: 실패
        - 쓰레드20 / maxAttempts = 15 / backoff = 200ms: 3210, 3240, 3217, 3169, 3231
        -
        - 쓰레드10 / maxAttempts = 5: 실패
        - 쓰레드10 / maxAttempts = 10 / backoff = 300ms: 2959, 2960, 2612, 2903, 2946
        - 쓰레드10 / maxAttempts = 15 / backoff = 100ms: 1248, 1060, 1250, 1130, 1210

#### 여러 명이 쿠폰 발급

- 쿠폰 발급은 쿠폰 발급 가능 수량보다 많은 수의 사용자가 동시에 쿠폰을 발급하는 경우가 발생할 수 있다.
- 테스트 시나리오
    - 쿠폰 발급 가능 수량은 N개고, 쿠폰 발급 요청은 N+1이다.
    - 발급된 쿠폰의 수량이 쿠폰 발급 가능 수량을 비교해서 동시성 문제가 발생했는지 확인한다.
- 비관적락(단위: ms)
    - 5회: 43, 44, 43, 36, 36
    - 50회: 353, 305, 273, 272, 233
    - 500회: 2459, 2161, 1999, 2142, 2105
    - 5000회: 25116, 26415, 25997, 25412, 25722
- 낙관적락(단위: ms)
    - 5회
        - 쓰레드20 / maxAttempts = 5 / backoff = 100ms: 511, 536, 507, 542, 533
        - 쓰레드20 / maxAttempts = 10 / backoff = 100ms: 516, 500, 497, 506, 511
        - 쓰레드20 / maxAttempts = 15 / backoff = 100ms: 522, 539, 507, 502, 515
        -
        - 쓰레드10 / maxAttempts = 5 / backoff = 100ms: 511, 536, 507, 542, 533
        - 쓰레드10 / maxAttempts = 10 / backoff = 100ms: 516, 500, 497, 506, 511
        - 쓰레드10 / maxAttempts = 15 / backoff = 100ms: 522, 539, 507, 502, 515
    - 50회
        - 쓰레드20 / maxAttempts = 5: 실패
        - 쓰레드20 / maxAttempts = 10: 실패
        - 쓰레드20 / maxAttempts = 15 / backoff = 100ms: 1053, 1504, 1161, 1328, 1781
        -
        - 쓰레드10 / maxAttempts = 5: 실패
        - 쓰레드10 / maxAttempts = 10 / backoff = 200ms: 2094, 1875, 2129, 2131, 2120
        - 쓰레드10 / maxAttempts = 15 / backoff = 100ms: 1512, 1299, 1405, 1244, 1197

#### 한 명이 여러 번 쿠폰 발급

- 동일한 유저가 동일한 쿠폰에 대해 여러 번 쿠폰을 발급하는 경우가 발생할 수 있다.
- 테스트 시나리오
    - 동일한 유저가 동일한 쿠폰에 대해 N번 쿠폰 발급 요청을 한다.
    - 발급된 쿠폰의 수량이 1개인지 확인한다.
    - 발급 가능한 쿠폰의 수량이 (N - 1)개인지 확인한다.
- 비관적락(단위: ms)
    - 5회: 30, 27, 32, 33, 26
    - 50회: 181, 137, 119, 173, 113
    - 500회: 912, 934, 788, 698, 595
    - 5000회: 6110, 5162, 4880, 5085, 4923
- 낙관적락(단위: ms)
    - 5회
        - 쓰레드20 / maxAttempts = 5 / backoff = 100ms: 136, 135, 136, 132, 132
        - 쓰레드20 / maxAttempts = 10 / backoff = 100ms: 136, 134, 131, 128, 129
        - 쓰레드20 / maxAttempts = 15 / backoff = 100ms: 133, 138, 135, 137, 137
        -
        - 쓰레드10 / maxAttempts = 5 / backoff = 100ms: 131, 131, 131, 129, 126
        - 쓰레드10 / maxAttempts = 10 / backoff = 100ms: 137, 131, 139, 131, 126
        - 쓰레드10 / maxAttempts = 15 / backoff = 100ms: 153, 133, 131, 130, 140
    - 50회
        - 쓰레드20 / maxAttempts = 5 / backoff = 100ms: 158, 184, 174, 176, 182
        - 쓰레드20 / maxAttempts = 10 / backoff = 100ms: 195, 267, 193, 147, 169
        - 쓰레드20 / maxAttempts = 15 / backoff = 100ms: 197, 194, 168, 182, 164
        -
        - 쓰레드10 / maxAttempts = 5 / backoff = 100ms: 168, 173, 154, 152, 137
        - 쓰레드10 / maxAttempts = 10 / backoff = 100ms: 156, 174, 164, 148, 146
        - 쓰레드10 / maxAttempts = 15 / backoff = 100ms: 219, 159, 221, 188, 142

#### 주문 생성

- 주문 생성 도중 주문 요청 상품의 재고가 변경되는 경우가 발생할 수 있다.
- 테스트 시나리오
    - (N - 1)개의 재고를 보유한 상품과 (N + 1)개의 재고를 보유한 상품을 N번 주문 생성 요청을 한다.
    - (N - 1)번의 주문이 생성되었는지 확인한다.
- 비관적락(단위: ms)
    - 5회: 71, 82, 71, 63, 52
    - 50회: 540, 445, 390, 597, 526
    - 500회: 3388, 3241, 2697, 2741, 2557
    - 5000회: 26695, 26672, 29263, 28560, 29305
- 낙관적락(단위: ms)
    - 5회
        - 쓰레드20 / maxAttempts = 5 / backoff = 100ms: 561, 542, 565, 539, 571
        - 쓰레드20 / maxAttempts = 10 / backoff = 100ms: 528, 557, 524, 535, 533
        - 쓰레드20 / maxAttempts = 15 / backoff = 100ms: 534, 530, 525, 540, 506
        -
        - 쓰레드10 / maxAttempts = 5 / backoff = 100ms: 544, 563, 533, 529, 513
        - 쓰레드10 / maxAttempts = 10 / backoff = 100ms: 519, 606, 608, 568, 514
        - 쓰레드10 / maxAttempts = 15 / backoff = 100ms: 547, 551, 581, 522, 520
    - 50회
        - 쓰레드20 / maxAttempts = 5: 실패
        - 쓰레드20 / maxAttempts = 10: 실패
        - 쓰레드20 / maxAttempts = 15 / backoff = 200ms: 3318, 3132, 3047, 3074, 3340
        -
        - 쓰레드10 / maxAttempts = 5: 실패
        - 쓰레드10 / maxAttempts = 10 / backoff = 300ms: 3089, 3073, 3078, 3055, 3009
        - 쓰레드10 / maxAttempts = 15 / backoff = 100ms: 1230, 1686, 1697, 1373, 1218

#### 결제

- 동일한 주문에 여러번 결제 요청을 하는 경우가 발생할 수 있다.
- 테스트 시나리오
    - 하나의 주문을 N번 결제 요청을 한다.
    - 생성된 결제가 1건인지 확인한다.
    - 결제 후 보유 포인트가 기존 포인트에서 결제 1회 금액만큼 차감되었는지 확인한다.
    - 주문의 상태가 결제 완료 상태로 되었는지 확인한다.
- 비관적락(단위: ms)
    - 5회: 16, 21, 16, 20, 14
    - 50회: 95, 55, 58, 73, 78
    - 500회: 455, 432, 388, 350, 329
    - 5000회: 3559, 3181, 2879, 2572, 2695
- 낙관적락(단위: ms)
    - 5회
        - 쓰레드20 / maxAttempts = 5 / backoff = 100ms: 126, 124, 127, 127, 123
        - 쓰레드20 / maxAttempts = 10 / backoff = 100ms: 125, 121, 126, 129, 122
        - 쓰레드20 / maxAttempts = 15 / backoff = 100ms: 127, 122, 125, 122, 120
        -
        - 쓰레드10 / maxAttempts = 5 / backoff = 100ms: 128, 127, 127, 128, 124
        - 쓰레드10 / maxAttempts = 10 / backoff = 100ms: 132, 126, 128, 124, 124
        - 쓰레드10 / maxAttempts = 15 / backoff = 100ms: 127, 131, 125, 125, 124
    - 50회
        - 쓰레드20 / maxAttempts = 5 / backoff = 100ms: 152, 179, 154, 126, 169
        - 쓰레드20 / maxAttempts = 10 / backoff = 100ms: 217, 160, 130, 131, 176
        - 쓰레드20 / maxAttempts = 15 / backoff = 100ms: 189, 150, 133, 133, 154
        -
        - 쓰레드10 / maxAttempts = 5 / backoff = 100ms: 140, 131, 130, 133, 126
        - 쓰레드10 / maxAttempts = 10 / backoff = 100ms: 153, 152, 149, 129, 134
        - 쓰레드10 / maxAttempts = 15 / backoff = 100ms: 142, 136, 165, 148, 130

</details>
